# JVM概述

> jvm作用

- 负责将字节码加载到内存（运行时数据区）
- 负责存储数据
- 将字节码编译成机器码，运行
- 垃圾回收机制

> jvm组成

- 类加载器
- 运行时数据区（存储运行时数据，本地方法栈，java虚拟机栈，堆，方法区，程序计数器）
- 执行引擎（更加底层，将字节码翻译成机器码）
- 本地方法接口
- 垃圾回收

# 类加载器

## 作用

负责从硬盘、网络中加载字节码信息；

加载到内存中（运行时数据区的方法区中）

## 类加载过程

**加载**

io读取字节码文件；

转换并存储，为每个类创建一个Class对象；

存储在方法区；

**链接**

> 验证

对字节码文件格式验证，文件是否被污染；

对基本的语法格式进行验证

> 准备

为静态的变量进行内存分配

```java
  public static int value = 123；
  //value 在准备阶段后的初始值是 0,而不是 123
```

静态常量在编译期间就初始化

> 解析

将符号引用转换为直接引用

将字节码中的表现形式转为内存中表现（内存地址）

**初始化**

类的初始化，为类中的定义的静态变量进行赋值

 public static int value = 123；这时就是123；

## 类什么时候初始化

- 再类中运行main方法
- 反射Class.forname（""）
- 创建对象
- 子类被加载
- 适用类的静态变量、静态方法

> 以下两种情况不会初始化

```java
static final int b = 20; //编译期间赋值的静态常量
System.out.println(User.b);
User[] users = new User[10];//作为数组类型
```

## 类加载器

具体的负责加载类的一些代码

> ##### 引导类加载器
>
> 用c、c++开发，负责加载java核心类库
>
> 与java语言无关

> ##### 扩展类加载器
>
> java语言编写
>
> 1. 由 sun.misc.Launcher$ExtClassLoader 实现,继承ClassLoader类；
> 2. 从 JDK 系统安装目录的 jre/lib/ext 子目录(扩展目录)下加载类库

> ##### 应用程序类加载器
>
>   Java 语言编写的
>
> 1. 由 sun.misc.Launcher$AppClassLoader 实现.   派生于 ClassLoader 类
> 2. 加载程序中自己开发的类

## 双亲委派机制

> 为了先确保加载系统类

1. 加载一个类时,先委托给父类加载器加载,如果父加载器没有找到,继续向上级委托,直到引导类加载器.
2.  父级找到就返回,父级如果最终没有找到,就委派给子级加载器,
3. 最终没有找到,报ClassNotFoundException.